HeLX Spec A 'Main'

// Let's look at Fizzbuzz for basic syntax
for i = 1 to i++ <= 30
	output = ''
	if i % 3 == 0, output += 'Fizz'
	if i % 5 == 0, output += 'Buzz'
	if output != '', print.( i output )

print.('')

// Now let's see how references work
arr = [
	[1 2 3]
	[4 5 6] ]
print.( 'Original Array:' arr )

arrCopy = arr.[0]
arrRef @= arr.[1]

arrCopy = 'Replaced'
arrRef = 'Replaced'

print.( 'Modified Array:' arr )
print.( 'Array Copy:' arrCopy )
print.( 'Array Reference:' arrRef )


print.('')

// References in a for loop
arr = [ 1..5 ]
print.( 'Original Array:' arr )

for i of arr, i ^= 2
print.( 'Array iterated w/ for of:' arr )

for i at arr, i ^= 2
print.( 'Array iterated w/ for @of:' arr )


print.('')

// Quick, a factorial function
fac = ( x ) >>
	if x == 0, << 1
	<< fac.( x-1 ) *x

print.( '5! =' fac.(5) )
print.( '10! =' fac.(10) )


print.('')

// Functions that don't return anything return a class instance
Lcg = ( seed mult inc mod ) >>
	mult ?= 378
	inc ?= 2310
	mod ?= 10000
	state: seed
	next: () >> << state = { state *mult +inc } %mod

rand = Lcg.( 1248 )
print.( 'Random number:' rand.next.() )
print.( 'Random number:' rand.next.() )
print.( 'Random number:' rand.next.() )


print.('')

// Encapsulated functional inheritance
Dice = () >>
	rng = Lcg.( JS.('Date.now()') 379 1234 6000 )
	roll: () >> << JS.('Math.ceil('+rng.next.()/1000+')')

dice = Dice.()
for i = 1 to i++ <= 5, print.( 'Dice roll:' dice.roll.() )


print.('')

// Concatenated functional inheritance
Multidice = Dice + ( count ) >>
	addDice: () >> count++
	removeDice: () >> count--
	rollAll: () >>
		total = 0
		for i = 1 to i++ <= count
			total += roll.()
		<< total
		
multidice = Multidice.( 5 )
for i = 1 to i++ <= 3, print.( '1 roll:' multidice.roll.() )
for i = 1 to i++ <= 3, print.( '5 rolls:' multidice.rollAll.() )
multidice.addDice.()
multidice.addDice.()
for i = 1 to i++ <= 3, print.( '7 rolls:' multidice.rollAll.() )


print.('')

// Lets add objects and arrays too
obj1 = () >>
	a: 1
	b: 1
obj1 = obj1.()
obj2 = () >>
	b: 2
	c: 2
obj2 = obj2.()
print.( obj1 obj2 obj1+obj2 )

arr1 = [ 1 2 ]
arr2 = [ 3 4 ]
print.( arr1 arr2 arr1+arr2 )



aaaaaaaaaaaa = 1
aaaaaaaaaaaa = 2
print.(aaaaaaaaaaaa)
/*

/*

// Arbitrary object

// Function compositions
today = { getUnixTime >> secsToDays >> StringThing }()

today = getUnixTime >> secsToDays >> today >>
	<< 'Today is ' + today + '!'
today = today()

# add = ( a b ) >> a + b // Hashtag enforces a pure function which are auto-curried
add5 = add( 5 )
result15 = add5( 10 )
result15 = add( 5 10 )

// Programmable langauge features
expr = () >> sin(1.1) * cos(2.03) // Taken from wikipedia Homoiconicity in Lisp example
expr = () >> ~'sin(' 1.1 ~')' ~'*' ~'cos(' 2.03 ~')' // ~ Evals a string
expr~4 = 'sin(' // var~4 gets the 4th ~ in var so expr now reads sin(1.1) * sin(2.03)
copy = ~24 // Evals line 24

# genHTML = ( tag inner attributes ) >> '<'+tag+' '+attributes+'>'+inner+'</'+tag+'>'
# genDiv = genHTML( 'div' ~ 'class="hlx"' ) // Isolated ~ indicates skip parameter
# genP = genHTML( 'p' ~ 'class="hlx"' )
divWithP =
	genDiv(
		genP(
			'Hello World!' )) // I recommend ending parens lisp-style
eqivToThis =
	genHTML( 'div'
		genHTML( 'p'
			'Hello World!'
		'class="hlx"' )
	'class="hlx"' )

~ Array::a ( + ) Array::b >> a.concat(b) // Operator overloading

// Monads
Identity = ( val ) >>
	value: val
~ Identity::i ( >>= ) Function::t >> t( i.value )

res = // Identity{ value: 11 }
	<< new Identity(5) >>= x >>
		<< new Identity(6) >>= y >>
			<< new Identity(x+y)
res = new Identity(5) >>= x >> new Identity(6) >>= y >> new Identity(x+y)


Just = ( val ) >>
	value: val
~ Just::j ( >> ) Function::t >> t( j.value ) // Just is just the same as Identity

Nothing = () >>
~ Nothing::j ( >> ) Function::t >> new Nothing

res =  // Nothing{ }
	<< new Just(5) >> x >>
		<< new Nothing >> y >>
			<< new Just(x+y)
res = new Just(5) >> x >> new Nothing >> y >> new Just(x+y)

safediv = ( n m ) >>
	if m == 0, << new Nothing
	<< new Just( n / m )
~ ( safe/ ) Float64::n >> new Just(n)
~ ( safe/ ) Float64::x Float64::y >>
	<< safe/ x >> n >>
		<< safe/ y >> m >>
			<< safediv( n m )
a = safe/ 10 2 // Just{ value: 5 }
a = safe/ 10 0 // Nothing{ }

// More # notation (immutable objs and async)
# img = new () >> // Hashtag before a variable declaration will make it immutable
	channels: [ 'k' ]
	bitDepth: 6
	dataA: ][
		[ 64 58 22 18 ]
		[ 62 56 20 16 ]
		[ 60 54 18 14 ]
		[ 58 52 16 12 ]
	dataB: ][
		[ 58 22 18 64 ]
		[ 56 20 16 62 ]
		[ 52 16 12 58 ]
		[ 54 18 14 60 ]

immutableImages.channels = [ 'This will fail' ] // Cannot change probs of immutable obj

expr <= # GET('https://example.com/imageBlendFunc.json') // Concurrent, save inputs
expr <= # GET('https://example.com/imageBlendFunc.json')
expr <= # GET('https://example.com/imageBlendFunc.json')
expr <= # GET('https://example.com/imageBlendFunc.json')
othr <= # GET('https://example.com/imageBlendFunc.json')
othr <= # GET('https://example.com/imageBlendFunc.json')

expr <=
	# GET('https://example.com/imageBlendFunc.json')
	# GET('https://example.com/imageBlendFunc.json')
	# GET('https://example.com/imageBlendFunc.json')
	# GET('https://example.com/imageBlendFunc.json')

total <=
	othr
	expr

expr >> // Start all inputs
	<< expr >> Unformat >> JSON.parse // Race

# pureFunc = ( expr ) >> // Pure immutable functions can use only immutable variable data
	Float64[][]::out
	for [ y x ] in [ img.dataA img.dataA[0] ]
		out[y][x] = expr( img.dataA[y][x] img.dataB[y][x] )
	<< out

mutableVar = 0
# thisWillFail = () >>
	print.( mutableVar ) // Fail

exprObject = new expr >> Unformat >> JSON.parse >> ExprBuilder // Object from chained pure funcs

for [ y x ] in [ [0 .. img.sizeY] [0 .. img.sizeX] ]
	out[y][x] = img.dataB[y][x] >> # { img.dataA[y][x] >> # expr }

switch epxr
	case 1
		thing
	case 2
	case 3


*/




