HeLX Spec A 'untitled' //Cmd-b builds, cmd-s downloads, cmd-k clears.

// Major differences from common programming languages:
// 0t is true, 0f is false
// 0n is null, 0u is undefined
// 0i is Infinity, 0l is epsilon (limit)
// 0v is NotANumber (think of it as void)
//
// Exponentiation operator is ^ (2^3 == 8)
// Bitwise xor is ^^, bitwise not is !! (typically ~)
// a ?= b means if a evaluates to 0f, then a = b. Otherwise, a stays the same
//
// Single quotes wrap normal strings
// Double quotes wrap template literals
// Forward slashes wrap regular expressions
//
// All variables are block scoped and no shadowing allowed
// PublicVariable = 3
// PrivateVariable: 3
// Public and private variables cannot have the same name
//
// Postfix inc/decrement (++i) not supported due to references implementation
// i++ is what ++i traditionally is. Traditional i++ does not exist
//
// Think of [] as array, () as function, and {} as an evaulation
// {3 +5} ^2 is valid while (3 +5) ^2 is not
//
// Finally, if you want to use something from Javascript,
// use it like JS('js statement here') i.e. JS('console.log')('Log This!')
// To export a value from HeLX to JS, use HLX( HeLX_value_here )

// Let's look at Fizzbuzz for basic syntax
for i of [ 1..30 ]
	output = ''
	if i % 3 == 0, output += 'Fizz'
	if i % 5 == 0, output += 'Buzz'
	if output != '', print( i output )


print('')

// Now let's see how references work
arr = [ [1 2 3] [4 5 6] ]
print( 'Original Array:' arr )

arrCopy = arr[0]
arrRef @= arr[1]

arrCopy = 'Replaced'
arrRef = 'Replaced'

print( 'Modified Array:' arr )
print( 'Array Copy:' arrCopy )
print( 'Array Reference:' arrRef )


print('')

// References in a for loop
arr = [ 1..5 ]
print( 'Original Array:' arr )

for i of arr, i ^= 2
print( 'Array iterated w/ for of:' arr )

for i @of arr, i ^= 2
print( 'Array iterated w/ for @of:' arr )


print('')

// Quick, a factorial function
fac = ( x ) =>
	if x == 0, return 1
	return fac( x-1 ) *x

print( '5! =' fac(5) )
print( '10! =' fac(10) )


print('')

// Functions that don't return anything return a class instance
Lcg = ( seed mult inc mod ) =>
	mult ?= 378
	inc ?= 2310
	mod ?= 10000
	state: seed
	next: () => state = { state *mult +inc } %mod

rand = Lcg( 1248 )
print( 'Random number:' rand.next() )
print( 'Random number:' rand.next() )
print( 'Random number:' rand.next() )


print('')

// Encapsulated functional inheritance
Dice = () =>
	rng = Lcg( JS('Date.now()') 379 1234 6000 )
	roll: () => JS('Math.ceil('+rng.next()/1000+')')
	
dice = Dice()
for i in [1..5], print( 'Dice roll:' dice.roll() )


print('')

// Concatenated functional inheritance
Multidice = Dice + ( count ) =>
	addDice: () => count++
	removeDice: () => count--
	rollAll: () =>
		total = 0
		i = 0, while i < count
			total += roll()
			i++
		return total
		
multidice = Multidice( 5 )
for i in [1..3], print( '1 roll: ' multidice.roll() )
for i in [1..3], print( '5 rolls: ' multidice.rollAll() )
multidice.addDice()
multidice.addDice()
for i in [1..3], print( '7 rolls: ' multidice.rollAll() )


print('')

// Lets add objects and arrays too
obj1 = () =>
	a: 1
	b: 1
obj1 = obj1()
obj2 = () =>
	b: 2
	c: 2
obj2 = obj2()
print( obj1 obj2 obj1+obj2 )

arr1 = [ 1 2 ]
arr2 = [ 3 4 ]
print( arr1 arr2 arr1+arr2 )
